AWSTemplateFormatVersion: '2010-09-09'
Description: 'Bug Tracker Dashboard - API and Ingestion Services'

Parameters:
  Environment:
    Type: String
    Default: 'dev'
    Description: 'Environment name (dev, staging, prod)'
  
  ShortcutApiToken:
    Type: String
    NoEcho: true
    Description: 'Shortcut API Token'
  
  SlackBotToken:
    Type: String
    NoEcho: true
    Description: 'Slack Bot Token'
  
  ZendeskDomain:
    Type: String
    Default: 'everyset'
    Description: 'Zendesk domain'
  
  ZendeskEmail:
    Type: String
    Description: 'Zendesk email'
  
  ZendeskApiToken:
    Type: String
    NoEcho: true
    Description: 'Zendesk API Token'

Resources:
  # S3 Bucket for Lambda deployment
  LambdaDeploymentBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'bugtracker-lambda-${Environment}-${AWS::AccountId}'
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldVersions
            Status: Enabled
            NoncurrentVersionExpirationInDays: 7

  # IAM Role for Lambda functions
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: 'BugTrackerLambdaRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: 'arn:aws:dynamodb:us-west-2:935779638706:table/BugTracker-evt-bugtracker'

  # Lambda function for data ingestion
  IngestionLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'BugTrackerIngestion'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 900  # 15 minutes
      MemorySize: 512
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          SHORTCUT_API_TOKEN: !Ref ShortcutApiToken
          SLACK_BOT_TOKEN: !Ref SlackBotToken
          ZENDESK_DOMAIN: !Ref ZendeskDomain
          ZENDESK_EMAIL: !Ref ZendeskEmail
          ZENDESK_API_TOKEN: !Ref ZendeskApiToken
          DYNAMODB_TABLE: 'BugTracker-evt-bugtracker'
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import urllib.request
          import urllib.parse
          import urllib.error
          from datetime import datetime, timedelta
          from botocore.exceptions import ClientError
          
          def lambda_handler(event, context):
              try:
                  # Initialize DynamoDB
                  dynamodb = boto3.resource('dynamodb')
                  table = dynamodb.Table(os.environ['DYNAMODB_TABLE'])
                  
                  # Run ingestion
                  result = run_ingestion(table)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Ingestion completed successfully',
                          'result': result
                      })
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': str(e)
                      })
                  }
          
          def run_ingestion(table):
              try:
                  print("üöÄ Starting automated ingestion...")
                  
                  # Initialize API tokens from environment
                  SHORTCUT_API_TOKEN = os.environ.get('SHORTCUT_API_TOKEN')
                  SLACK_BOT_TOKEN = os.environ.get('SLACK_BOT_TOKEN')
                  ZENDESK_DOMAIN = os.environ.get('ZENDESK_DOMAIN')
                  ZENDESK_EMAIL = os.environ.get('ZENDESK_EMAIL')
                  ZENDESK_API_TOKEN = os.environ.get('ZENDESK_API_TOKEN')
                  
                  print(f"‚úÖ Environment variables loaded: Shortcut={bool(SHORTCUT_API_TOKEN)}, Slack={bool(SLACK_BOT_TOKEN)}, Zendesk={bool(ZENDESK_API_TOKEN)}")
                  
                  # Run ingestion for each source
                  results = {
                      'shortcut': 0,
                      'slack': 0,
                      'zendesk': 0,
                      'errors': []
                  }
                  
                  # Zendesk ingestion
                  if ZENDESK_API_TOKEN:
                      try:
                          zendesk_bugs = ingest_zendesk_tickets(ZENDESK_DOMAIN, ZENDESK_EMAIL, ZENDESK_API_TOKEN)
                          for bug in zendesk_bugs:
                              table.put_item(Item=bug)
                          results['zendesk'] = len(zendesk_bugs)
                          print(f"‚úÖ Ingested {len(zendesk_bugs)} Zendesk bugs")
                      except Exception as e:
                          error_msg = f"Zendesk ingestion error: {str(e)}"
                          print(f"‚ùå {error_msg}")
                          results['errors'].append(error_msg)
                  
                  print(f"üéâ Ingestion completed: {results}")
                  return results
                  
              except Exception as e:
                  error_msg = f"General ingestion error: {str(e)}"
                  print(f"‚ùå {error_msg}")
                  return {'errors': [error_msg]}
          
          def ingest_zendesk_tickets(domain, email, api_token):
              """Ingest tickets from Zendesk"""
              print("üîç Fetching Zendesk tickets...")
              
              if not all([domain, email, api_token]):
                  print("‚ùå Missing Zendesk credentials")
                  return []
              
              try:
                  # Zendesk API endpoint for tickets
                  url = f"https://{domain}.zendesk.com/api/v2/search.json"
                  
                  # Search for tickets with specific criteria
                  params = {
                      'query': 'type:ticket',
                      'sort_by': 'created_at',
                      'sort_order': 'desc'
                  }
                  
                  # Add parameters to URL
                  url_with_params = url + '?' + urllib.parse.urlencode(params)
                  
                  # Create basic auth header
                  import base64
                  credentials = f"{email}/token:{api_token}"
                  encoded_credentials = base64.b64encode(credentials.encode()).decode()
                  headers = {
                      'Authorization': f'Basic {encoded_credentials}',
                      'Content-Type': 'application/json'
                  }
                  
                  # Make request
                  req = urllib.request.Request(url_with_params, headers=headers)
                  with urllib.request.urlopen(req) as response:
                      data = json.loads(response.read().decode())
                  
                  tickets = data.get('results', [])
                  print(f"‚úÖ Found {len(tickets)} Zendesk tickets")
                  
                  zendesk_bugs = []
                  
                  for ticket in tickets:
                      # Only include tickets that are likely bugs
                      subject = ticket.get('subject', '').lower()
                      description = ticket.get('description', '').lower()
                      tags = [tag.lower() for tag in ticket.get('tags', [])]
                      
                      # Check if this looks like a bug
                      is_bug = (
                          'bug' in subject or 'bug' in description or 'bug' in tags or
                          'error' in subject or 'error' in description or 'error' in tags or
                          'issue' in subject or 'issue' in description or 'issue' in tags or
                          'problem' in subject or 'problem' in description or 'problem' in tags
                      )
                      
                      if is_bug:
                          # Determine priority
                          priority_map = {
                              'urgent': 'Critical',
                              'high': 'High',
                              'normal': 'Medium',
                              'low': 'Low'
                          }
                          priority = priority_map.get(ticket.get('priority', 'normal'), 'Medium')
                          
                          bug = {
                              'PK': f"ZD-{ticket['id']}",
                              'SK': f"zendesk#{ticket['id']}",
                              'sourceSystem': 'zendesk',
                              'priority': priority,
                              'status': ticket.get('status', 'Unknown'),
                              'subject': ticket.get('subject', 'No subject'),
                              'text': ticket.get('description', ''),
                              'createdAt': ticket.get('created_at', datetime.now().isoformat()),
                              'updatedAt': ticket.get('updated_at', datetime.now().isoformat()),
                              'requester': ticket.get('requester_id', 'Unknown'),
                              'assignee': ticket.get('assignee_id', 'Unassigned'),
                              'tags': ticket.get('tags', [])
                          }
                          zendesk_bugs.append(bug)
                  
                  print(f"‚úÖ Processed {len(zendesk_bugs)} Zendesk bug tickets")
                  return zendesk_bugs
                  
              except Exception as e:
                  print(f"‚ùå Error fetching Zendesk tickets: {e}")
                  return []

  # EventBridge Rule for scheduled ingestion
  IngestionSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: 'BugTrackerIngestionSchedule'
      Description: 'Schedule for bug tracker data ingestion'
      ScheduleExpression: 'rate(1 hour)'
      State: ENABLED
      Targets:
        - Arn: !GetAtt IngestionLambda.Arn
          Id: IngestionTarget

  # Permission for EventBridge to invoke Lambda
  EventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref IngestionLambda
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt IngestionSchedule.Arn

  # API Gateway for backend API
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: 'BugTrackerAPI'
      Description: 'Bug Tracker Dashboard API'

  # API Gateway Deployment
  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: ApiGatewayMethod
    Properties:
      RestApiId: !Ref ApiGateway
      StageName: !Ref Environment

  # API Gateway Resource
  ApiGatewayResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: 'bugs'

  # API Gateway Method
  ApiGatewayMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiLambda.Arn}/invocations'

  # API Gateway Method for OPTIONS (CORS)
  ApiGatewayMethodOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: '{"statusCode": 200}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # Lambda function for API
  ApiLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'BugTrackerAPI'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          DYNAMODB_TABLE: 'BugTracker-evt-bugtracker'
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from botocore.exceptions import ClientError
          
          def lambda_handler(event, context):
              try:
                  # Parse query parameters
                  query_params = event.get('queryStringParameters', {}) or {}
                  query_type = query_params.get('query_type', 'summary')
                  source_system = query_params.get('source_system', 'all')
                  start_date = query_params.get('start_date')
                  end_date = query_params.get('end_date')
                  
                  # Initialize DynamoDB
                  dynamodb = boto3.resource('dynamodb')
                  table = dynamodb.Table(os.environ['DYNAMODB_TABLE'])
                  
                  # Handle different query types
                  if query_type == 'summary':
                      result = get_summary(table, source_system, start_date, end_date)
                  elif query_type == 'time_series':
                      result = get_time_series(table, source_system, start_date, end_date)
                  elif query_type == 'by_source':
                      result = get_by_source(table, source_system, start_date, end_date)
                  else:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'Invalid query_type'})
                      }
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS'
                      },
                      'body': json.dumps(result)
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
          
          def get_summary(table, source_system, start_date, end_date):
              try:
                  # Scan DynamoDB table
                  scan_kwargs = {}
                  
                  # Add source filter if specified
                  if source_system and source_system != 'all':
                      scan_kwargs['FilterExpression'] = boto3.dynamodb.conditions.Attr('sourceSystem').eq(source_system)
                  
                  # Add date filters if specified
                  if start_date or end_date:
                      date_filter = boto3.dynamodb.conditions.Attr('createdAt')
                      if start_date:
                          date_filter = date_filter.gte(start_date)
                      if end_date:
                          date_filter = date_filter.lte(end_date)
                      
                      if 'FilterExpression' in scan_kwargs:
                          scan_kwargs['FilterExpression'] = scan_kwargs['FilterExpression'] & date_filter
                      else:
                          scan_kwargs['FilterExpression'] = date_filter
                  
                  response = table.scan(**scan_kwargs)
                  items = response.get('Items', [])
                  
                  # Continue scanning if there are more items
                  while 'LastEvaluatedKey' in response:
                      scan_kwargs['ExclusiveStartKey'] = response['LastEvaluatedKey']
                      response = table.scan(**scan_kwargs)
                      items.extend(response.get('Items', []))
                  
                  # Calculate summary statistics
                  total = len(items)
                  by_source = {}
                  by_priority = {}
                  by_state = {}
                  
                  for item in items:
                      # Count by source
                      source = item.get('sourceSystem', 'Unknown')
                      by_source[source] = by_source.get(source, 0) + 1
                      
                      # Count by priority
                      priority = item.get('priority', 'Unknown')
                      by_priority[priority] = by_priority.get(priority, 0) + 1
                      
                      # Count by state/status
                      state = item.get('state') or item.get('status', 'Unknown')
                      by_state[state] = by_state.get(state, 0) + 1
                  
                  return {
                      'total': total,
                      'by_source': by_source,
                      'by_priority': by_priority,
                      'by_state': by_state
                  }
              except Exception as e:
                  print(f"Error in get_summary: {e}")
                  return {'total': 0, 'by_source': {}, 'by_priority': {}, 'by_state': {}}
          
          def get_time_series(table, source_system, start_date, end_date):
              try:
                  # Similar scan logic as get_summary
                  scan_kwargs = {}
                  
                  if source_system and source_system != 'all':
                      scan_kwargs['FilterExpression'] = boto3.dynamodb.conditions.Attr('sourceSystem').eq(source_system)
                  
                  if start_date or end_date:
                      date_filter = boto3.dynamodb.conditions.Attr('createdAt')
                      if start_date:
                          date_filter = date_filter.gte(start_date)
                      if end_date:
                          date_filter = date_filter.lte(end_date)
                      
                      if 'FilterExpression' in scan_kwargs:
                          scan_kwargs['FilterExpression'] = scan_kwargs['FilterExpression'] & date_filter
                      else:
                          scan_kwargs['FilterExpression'] = date_filter
                  
                  response = table.scan(**scan_kwargs)
                  items = response.get('Items', [])
                  
                  while 'LastEvaluatedKey' in response:
                      scan_kwargs['ExclusiveStartKey'] = response['LastEvaluatedKey']
                      response = table.scan(**scan_kwargs)
                      items.extend(response.get('Items', []))
                  
                  # Group by date
                  from collections import defaultdict
                  daily_counts = defaultdict(int)
                  
                  for item in items:
                      created_at = item.get('createdAt', '')
                      if created_at:
                          # Extract date part (YYYY-MM-DD)
                          date_part = created_at.split('T')[0] if 'T' in created_at else created_at[:10]
                          daily_counts[date_part] += 1
                  
                  # Convert to sorted list
                  time_series_data = [{'date': date, 'count': count} for date, count in sorted(daily_counts.items())]
                  
                  return {'data': time_series_data}
              except Exception as e:
                  print(f"Error in get_time_series: {e}")
                  return {'data': []}
          
          def get_by_source(table, source_system, start_date=None, end_date=None):
              try:
                  # Scan DynamoDB table
                  scan_kwargs = {}
                  
                  # Add source filter if specified
                  if source_system and source_system != 'all':
                      scan_kwargs['FilterExpression'] = boto3.dynamodb.conditions.Attr('sourceSystem').eq(source_system)
                  
                  # Add date filters if specified
                  if start_date or end_date:
                      date_filter = boto3.dynamodb.conditions.Attr('createdAt')
                      if start_date:
                          # Convert to ISO format for DynamoDB comparison
                          start_date_iso = f"{start_date}T00:00:00Z"
                          date_filter = date_filter.gte(start_date_iso)
                      if end_date:
                          # Convert to ISO format for DynamoDB comparison
                          end_date_iso = f"{end_date}T23:59:59Z"
                          date_filter = date_filter.lte(end_date_iso)
                      
                      if 'FilterExpression' in scan_kwargs:
                          scan_kwargs['FilterExpression'] = scan_kwargs['FilterExpression'] & date_filter
                      else:
                          scan_kwargs['FilterExpression'] = date_filter
                  
                  response = table.scan(**scan_kwargs)
                  items = response.get('Items', [])
                  
                  # Continue scanning if there are more items
                  while 'LastEvaluatedKey' in response:
                      scan_kwargs['ExclusiveStartKey'] = response['LastEvaluatedKey']
                      response = table.scan(**scan_kwargs)
                      items.extend(response.get('Items', []))
                  
                  # Convert Decimal types to regular numbers for JSON serialization
                  import decimal
                  def convert_decimals(obj):
                      if isinstance(obj, dict):
                          return {k: convert_decimals(v) for k, v in obj.items()}
                      elif isinstance(obj, list):
                          return [convert_decimals(v) for v in obj]
                      elif isinstance(obj, decimal.Decimal):
                          return float(obj)
                      else:
                          return obj
                  
                  items = convert_decimals(items)
                  
                  return {'items': items}
              except Exception as e:
                  print(f"Error in get_by_source: {e}")
                  return {'items': []}

  # Permission for API Gateway to invoke Lambda
  ApiGatewayPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ApiLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

Outputs:
  DynamoDBTableName:
    Description: 'DynamoDB table name'
    Value: 'BugTracker-evt-bugtracker'
    Export:
      Name: !Sub '${AWS::StackName}-DynamoDBTable'

  ApiGatewayUrl:
    Description: 'API Gateway URL'
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-ApiGatewayUrl'

  IngestionLambdaArn:
    Description: 'Ingestion Lambda ARN'
    Value: !GetAtt IngestionLambda.Arn
    Export:
      Name: !Sub '${AWS::StackName}-IngestionLambda'

  ApiLambdaArn:
    Description: 'API Lambda ARN'
    Value: !GetAtt ApiLambda.Arn
    Export:
      Name: !Sub '${AWS::StackName}-ApiLambda'
